<!DOCTYPE html>
<html lang="{{ page.lang | default: site.lang | default: "en" }}">

{%- include head.html -%}

<body class="chat-layout">

  <!-- 텔레그램 스타일 프로필 모달 -->
  <div id="profileModal" class="tg-modal">
    <div class="tg-modal-overlay"></div>
    <div class="tg-profile-card">
      <div class="tg-profile-header">
        <div class="tg-avatar">
          <img src="/images/face2.jpeg" alt="Profile" class="tg-avatar-img">
          <div class="tg-online-status"></div>
        </div>
        <h3 class="tg-profile-name">김지훈</h3>
        <p class="tg-profile-status">백엔드 개발자</p>
        <p class="tg-last-seen">온라인</p>
      </div>
      
      <div class="tg-profile-info">
        <div class="tg-info-item">
          <div class="tg-info-icon">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
              <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" stroke="currentColor" stroke-width="2"/>
              <circle cx="12" cy="7" r="4" stroke="currentColor" stroke-width="2"/>
            </svg>
          </div>
          <div class="tg-info-content">
            <div class="tg-info-label">경력</div>
            <div class="tg-info-value">3년차</div>
          </div>
        </div>
        
        <div class="tg-info-item">
          <div class="tg-info-icon">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
              <polyline points="16,18 22,12 16,6" stroke="currentColor" stroke-width="2"/>
              <polyline points="8,6 2,12 8,18" stroke="currentColor" stroke-width="2"/>
            </svg>
          </div>
          <div class="tg-info-content">
            <div class="tg-info-label">전문분야</div>
            <div class="tg-info-value">백엔드, DevOps, 미디어</div>
          </div>
        </div>
      </div>
      
      <div class="tg-contact-actions">
        <a href="mailto:wjstls123@gmail.com" class="tg-action-btn tg-email-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" stroke="currentColor" stroke-width="2"/>
            <polyline points="22,6 12,13 2,6" stroke="currentColor" stroke-width="2"/>
          </svg>
          <span>이메일</span>
        </a>
        
        <a href="https://github.com/tlqhrm" target="_blank" class="tg-action-btn tg-github-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" stroke="currentColor" stroke-width="2"/>
          </svg>
          <span>GitHub</span>
        </a>
      </div>
      
      <button id="closeProfile" class="tg-close-btn">닫기</button>
    </div>
  </div>

  <!-- 이미지 확대 모달 -->
  <div id="imageModal" class="image-modal">
    <div class="modal-content">
      <img id="modalImage" class="modal-image" src="" alt="">
      <button id="modalClose" class="modal-close">×</button>
      <button id="modalPrev" class="modal-nav prev">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="15,18 9,12 15,6"></polyline>
        </svg>
      </button>
      <button id="modalNext" class="modal-nav next">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="9,18 15,12 9,6"></polyline>
        </svg>
      </button>
    </div>
  </div>

  <div class="main-wrapper">
    <!-- PC용 사이드바 -->
    <div class="sidebar" id="sidebar">
      <nav class="sidebar-nav">
        <a href="#intro" class="nav-item active" data-section="intro">
          <span class="nav-icon">•</span>
          <span class="nav-text">자기소개</span>
        </a>
        <a href="#skills-backend" class="nav-item" data-section="skills-backend">
          <span class="nav-icon">•</span>
          <span class="nav-text">기술 스택</span>
        </a>
        <a href="#experience" class="nav-item" data-section="experience">
          <span class="nav-icon">•</span>
          <span class="nav-text">경력</span>
        </a>
        <a href="#projects" class="nav-item" data-section="projects">
          <span class="nav-icon">•</span>
          <span class="nav-text">프로젝트</span>
        </a>
        <a href="#certifications" class="nav-item" data-section="certifications">
          <span class="nav-icon">•</span>
          <span class="nav-text">자격증</span>
        </a>
      </nav>
    </div>

    <div class="chat-container">
      <div class="chat-header">
        <div class="header-content">
          <div class="header-left">
            <div class="header-title">
              <h1 id="headerTitle">{{ page.title | default: "Developer Portfolio" }}</h1>
              <div class="breadcrumb" id="breadcrumb" style="display: none;">
                <span class="breadcrumb-current" id="currentSection">자기소개</span>
              </div>
            </div>
          </div>
          <div class="header-right">
            <div class="mode-toggle">
              <div class="toggle-container">
                <span class="toggle-label left-label">대화형</span>
                <button id="modeToggle" class="toggle-switch chat-mode-active" title="PDF 형태로 전환">
                  <div class="toggle-track">
                    <div class="toggle-thumb">
                      <span class="toggle-icon chat-icon">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                      </span>
                      <span class="toggle-icon pdf-icon">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                          <polyline points="14,2 14,8 20,8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                      </span>
                    </div>
                  </div>
                </button>
                <span class="toggle-label right-label">PDF</span>
              </div>
            </div>
            <div class="pdf-download">
              <button id="pdfDownload" class="download-btn" title="PDF 다운로드">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="7,10 12,15 17,10"/>
                  <line x1="12" x2="12" y1="15" y2="3"/>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="chat-messages" id="chatMessages">
        {{ content }}
      </div>

      <!-- 모바일/태블릿용 가로 슬라이딩 네비게이션 -->
      <div id="mobileNav" class="mobile-nav">
        <div class="mobile-nav-container">
          <a href="#intro" class="mobile-nav-item active" data-section="intro">
            <span class="mobile-nav-text">자기소개</span>
          </a>
          <a href="#skills-backend" class="mobile-nav-item" data-section="skills-backend">
            <span class="mobile-nav-text">기술 스택</span>
          </a>
          <a href="#experience" class="mobile-nav-item" data-section="experience">
            <span class="mobile-nav-text">경력</span>
          </a>
          <a href="#projects" class="mobile-nav-item" data-section="projects">
            <span class="mobile-nav-text">프로젝트</span>
          </a>
          <a href="#certifications" class="mobile-nav-item" data-section="certifications">
            <span class="mobile-nav-text">자격증</span>
          </a>
        </div>
      </div>

      <!-- 입력창 -->
      <div class="chat-input-container">
        <div class="chat-input-wrapper">
          <input type="text" id="chatInput" class="chat-input" placeholder="" readonly>
          <button id="sendButton" class="send-button">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
              <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- 가짜 커서 -->
  <div id="fakeCursor" class="fake-cursor"></div>
    </div>
  </div>

  <script>
    // 미리 정의된 질문들
    const questions = [
      "안녕하세요! 자기소개 부탁드립니다.",
      "기술 스택에 대해 알려주세요.",
      "어떤 경력이 있으신가요?",
      "어떤 프로젝트들을 진행해보셨나요?",
      "어떤 자격증을 보유하고 계신가요?"
    ];

    // 섹션 이름 매핑
    const sectionNames = {
      'intro': '자기소개',
      'skills-backend': '기술 스택',
      'experience': '경력',
      'projects': '프로젝트',
      'certifications': '자격증'
    };

    let currentSectionIndex = 0;
    let isTyping = false;
    let lastMouseX = window.innerWidth / 2;
    let lastMouseY = window.innerHeight / 2;
    let isFirstAnimation = true;

    // 페이지 로드 시 초기화
    document.addEventListener('DOMContentLoaded', function() {
      initializeChat();
      initializePdfDownload();
    });

    function initializeChat() {
      // 모든 답변 메시지에 아바타 컨테이너 추가
      document.querySelectorAll('.answer').forEach((answer) => {
        if (!answer.querySelector('.avatar-container')) {
          const section = answer.closest('.chat-section');
          const isFirstInSection = section.querySelector('.answer') === answer;

          const avatarContainer = document.createElement('div');
          avatarContainer.className = 'avatar-container';

          if (isFirstInSection) {
            const avatar = document.createElement('div');
            avatar.className = 'avatar profile-avatar clickable-avatar';
            avatar.addEventListener('click', function() {
              document.getElementById('profileModal').style.display = 'block';
            });
            avatarContainer.appendChild(avatar);
          }

          answer.insertBefore(avatarContainer, answer.querySelector('.message'));
        }
      });

      // 질문 메시지에 아바타 추가
      updateQuestionAvatars();

      // 사이드바 네비게이션 초기화
      initializeSidebarNavigation();

      // 프로필 모달 이벤트 리스너
      initializeProfileModal();

      // 채팅 입력 초기화
      initializeChatInput();

      // 모드 토글 초기화
      initializeModeToggle();

      // 항상 대화형 모드로 설정
      document.body.classList.add('chat-mode');

      // 초기 상태 설정: 모든 섹션 숨기기
      hideAllSections();

      // OS 감지 및 가짜 커서 설정
      setupFakeCursor();

      // 마우스 위치 추적
      trackMousePosition();

      // 시작 시스템 메시지 표시
      setTimeout(() => {
        showStartMessage();
      }, 100);

      // 첫 번째 질문 자동 시작 (시스템 메시지 후)
      setTimeout(() => {
        startFirstConversation();
      }, 375);
    }

    function hideAllSections() {
      const sections = document.querySelectorAll('.chat-section');
      sections.forEach(section => {
        section.style.display = 'none';
      });
    }



    function setupFakeCursor() {
      const fakeCursor = document.getElementById('fakeCursor');

      // 기본 커서로 시작
      fakeCursor.classList.add('normal');
    }

    function trackMousePosition() {
      // 마우스 움직임 추적
      document.addEventListener('mousemove', function(e) {
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      });
    }

    function animateFakeCursor() {
      // 첫 번째 자동 애니메이션
      animateFakeCursorToButton(() => {
        sendMessage();
        isFirstAnimation = false; // 첫 번째 애니메이션 완료 표시
      });
    }

    function animateFakeCursorToButton(callback) {
      const fakeCursor = document.getElementById('fakeCursor');
      const sendButton = document.getElementById('sendButton');

      // 전송 버튼 위치 가져오기
      const buttonRect = sendButton.getBoundingClientRect();
      const cursorSize = 48; // 커서 크기 (48px)
      const offset = cursorSize / 2; // 중앙 정렬을 위한 오프셋

      // 실제 마우스 위치부터 시작
      const startX = lastMouseX - offset;
      const startY = lastMouseY - offset;
      const endX = buttonRect.left + buttonRect.width / 2 - offset;
      const endY = buttonRect.top + buttonRect.height / 2 - offset;

      // 가짜 커서 시작 위치 설정 (실제 마우스 위치)
      fakeCursor.style.left = startX + 'px';
      fakeCursor.style.top = startY + 'px';
      fakeCursor.classList.add('show');

      // 전송 버튼으로 이동
      setTimeout(() => {
        fakeCursor.style.left = endX + 'px';
        fakeCursor.style.top = endY + 'px';

        // 버튼에 도달하면 포인팅 핸드로 변경
        setTimeout(() => {
          fakeCursor.classList.remove('normal');
          fakeCursor.classList.add('pointing');
          sendButton.classList.add('cursor-hover');

          // 클릭 효과
          setTimeout(() => {
            sendButton.classList.add('cursor-click');

            // 콜백 실행 (메시지 전송)
            setTimeout(() => {
              if (callback) callback();

              // 가짜 커서 숨기기 및 초기화
              fakeCursor.classList.remove('show', 'pointing');
              fakeCursor.classList.add('normal');
              sendButton.classList.remove('cursor-hover', 'cursor-click');
            }, 150);

          }, 200);
        }, 500);
      }, 100);
    }

    function startFirstConversation() {
      const chatInput = document.getElementById('chatInput');
      const sendButton = document.getElementById('sendButton');

      // 대화형 모드에서 사용자가 처음 스크롤하면 첫 번째 질문 표시
      hasUserScrolledInChatMode = true;

      // 첫 번째 질문 바로 입력
      chatInput.value = questions[0];
      chatInput.disabled = false;
      sendButton.disabled = false;

      // 가짜 커서 애니메이션 시작
      setTimeout(() => {
        animateFakeCursor();
      }, 250);
    }

    function typeMessage(message, input, callback) {
      if (isTyping) return;

      isTyping = true;
      input.value = '';
      let i = 0;

      const typing = setInterval(() => {
        input.value += message[i];
        i++;

        if (i >= message.length) {
          clearInterval(typing);
          isTyping = false;
          if (callback) callback();
        }
      }, 50);
    }

    function showEndMessage() {
      const endMessage = document.getElementById('end-message');
      if (endMessage) {
        endMessage.style.display = 'block';
        setTimeout(() => {
          endMessage.classList.add('show');
        }, 100);
      }
    }

    function sendMessage() {
      const chatInput = document.getElementById('chatInput');
      const sendButton = document.getElementById('sendButton');

      if (isTyping) return;

      const sectionIds = ['intro', 'skills-backend', 'experience', 'projects', 'certifications'];
      const currentSectionId = sectionIds[currentSectionIndex];

      if (currentSectionId) {
        const targetElement = document.getElementById(currentSectionId);

        if (targetElement) {
          // 스크롤 입력 무시 시작
          disableScrollInput();

          // 목차 클릭과 동일한 효과: 클릭한 섹션까지의 모든 섹션 표시
          showSectionsUpTo(currentSectionId);

          // 첫 번째 질문(자기소개)이 아닌 경우만 스크롤
          if (currentSectionId !== 'intro') {
            // 부드러운 스크롤 (모바일 최적화)
            setTimeout(() => {
              const isMobile = window.innerWidth <= 480;
              const isFirstSection = currentSectionId === 'intro';

              if (isMobile) {
                if (isFirstSection) {
                  // 첫 번째 섹션은 맨 위로 스크롤
                  document.querySelector('.chat-messages').scrollTo({
                    top: 0,
                    behavior: 'smooth'
                  });
                } else {
                  // 다른 섹션들은 질문 부분이 보이도록 조정
                  const chatMessages = document.querySelector('.chat-messages');
                  const targetRect = targetElement.getBoundingClientRect();
                  const containerRect = chatMessages.getBoundingClientRect();
                  const headerHeight = document.querySelector('.chat-header').offsetHeight;

                  // 현재 스크롤 위치에서 타겟까지의 거리 계산
                  const scrollTop = chatMessages.scrollTop;
                  const targetTop = targetElement.offsetTop;

                  // 헤더 높이를 고려한 스크롤 위치
                  const finalScrollTop = targetTop - headerHeight - 20; // 20px 여백

                  chatMessages.scrollTo({
                    top: Math.max(0, finalScrollTop),
                    behavior: 'smooth'
                  });
                }
              } else {
                targetElement.scrollIntoView({
                  behavior: 'smooth',
                  block: 'start'
                });
              }

              // 스크롤 완료 후 입력 다시 활성화
              setTimeout(() => {
                enableScrollInput();
              }, 1000); // 스크롤 애니메이션 시간 고려
            }, 100);
          } else {
            // 첫 번째 섹션인 경우 바로 입력 활성화
            enableScrollInput();
          }

          // 입력창 비우기
          chatInput.value = '';

          // 네비게이션 활성 상태 업데이트 (먼저)
          updateActiveNavItem(currentSectionId);

          // 다음 질문 준비
          prepareNextQuestion();
        }
      }
    }

    let scrollInputDisabled = false;
    let hasUserScrolledInChatMode = false;
    let chatModeState = {
      visibleSections: [],
      currentSectionIndex: 0,
      hasUserScrolled: false
    };

    function disableScrollInput() {
      scrollInputDisabled = true;
    }

    function enableScrollInput() {
      scrollInputDisabled = false;
    }

    function showCurrentSectionInSpace() {
      const sectionIds = ['intro', 'skills-backend', 'experience', 'projects', 'certifications'];
      const currentSectionId = sectionIds[currentSectionIndex];
      const prevSectionId = sectionIds[currentSectionIndex - 1];

      // 이전 섹션의 여백 공간 찾기
      const nextQuestionSpace = document.getElementById('next-' + prevSectionId);

      if (nextQuestionSpace && currentSectionId) {
        // 현재 섹션의 내용을 가져와서 이전 섹션의 여백에 넣기
        const currentSection = document.getElementById(currentSectionId);
        if (currentSection) {
          nextQuestionSpace.innerHTML = currentSection.innerHTML;
          nextQuestionSpace.style.display = 'block';

          // 새로 추가된 섹션에 아바타 추가
          addAvatarsToSection(nextQuestionSpace);
        }
      }
    }

    function addAvatarsToSection(sectionElement) {
      // 답변 메시지에 아바타 컨테이너 추가
      sectionElement.querySelectorAll('.answer').forEach((answer) => {
        if (!answer.querySelector('.avatar-container')) {
          const avatarContainer = document.createElement('div');
          avatarContainer.className = 'avatar-container';

          const avatar = document.createElement('div');
          avatar.className = 'avatar profile-avatar clickable-avatar';
          avatar.addEventListener('click', function() {
            document.getElementById('profileModal').style.display = 'block';
          });
          avatarContainer.appendChild(avatar);

          answer.insertBefore(avatarContainer, answer.querySelector('.message'));
        }
      });

      // 질문 메시지에 아바타 추가
      sectionElement.querySelectorAll('.question').forEach(question => {
        let avatarContainer = question.querySelector('.avatar-container');

        if (!avatarContainer) {
          avatarContainer = document.createElement('div');
          avatarContainer.className = 'avatar-container';

          const avatar = document.createElement('div');
          avatar.className = 'avatar user-avatar';
          // SVG 제거: 이제 CSS 배경 이미지(챗봇.jpg) 사용

          avatarContainer.appendChild(avatar);
          question.appendChild(avatarContainer);
        }
      });
    }


    function showCurrentSection() {
      const sections = document.querySelectorAll('.chat-section');
      if (sections[currentSectionIndex]) {
        const section = sections[currentSectionIndex];
        section.style.display = 'block';

        // 질문과 답변을 순차적으로 나타내기
        const question = section.querySelector('.question');
        const answers = section.querySelectorAll('.answer');

        if (question) {
          // 순차 표시용 클래스 추가
          question.classList.add('sequential');
          answers.forEach(answer => answer.classList.add('sequential'));

          // 질문 먼저 표시
          question.classList.add('show');

          // 0.5초 후 답변들 순차적으로 표시
          setTimeout(() => {
            answers.forEach((answer, index) => {
              setTimeout(() => {
                answer.classList.add('show');
              }, index * 200); // 각 답변마다 0.2초씩 딜레이
            });
          }, 500); // 질문 후 0.5초 딜레이
        }
      }
    }


    function showStartMessage() {
      const startMessage = document.getElementById('start-message');
      if (startMessage) {
        startMessage.style.display = 'block';
        setTimeout(() => {
          startMessage.classList.add('show');
        }, 100);
      }
    }


    function prepareNextQuestion() {
      const chatInput = document.getElementById('chatInput');
      const sendButton = document.getElementById('sendButton');

      currentSectionIndex++;

      if (currentSectionIndex < questions.length) {
        // 다음 질문이 화면에 보이는지 확인 (원래대로 복구)
        setTimeout(() => {
          checkAndAutoFillQuestion();
        }, 1100);
      } else {
        // 모든 대화 완료 - 종료 메시지 표시 및 입력창 비활성화
        showEndMessage();
        chatInput.value = '';
        chatInput.placeholder = '';
        chatInput.disabled = true;
        sendButton.disabled = true;
      }
    }

    function checkAndAutoFillQuestion() {
      const chatInput = document.getElementById('chatInput');
      const sendButton = document.getElementById('sendButton');
      const chatMessages = document.getElementById('chatMessages');

      if (currentSectionIndex < questions.length) {
        const sections = document.querySelectorAll('.chat-section');
        const nextSection = sections[currentSectionIndex];

        if (nextSection) {
          const rect = nextSection.getBoundingClientRect();
          const containerRect = chatMessages.getBoundingClientRect();

          // 다음 섹션이 화면에 보이면 (또는 곧 보일 위치에 있으면)
          if (rect.top <= containerRect.bottom + 200) {
            // 대화형 모드에서 사용자가 스크롤하지 않았으면 질문 표시하지 않음
            if (!hasUserScrolledInChatMode) {
              chatInput.disabled = true;
              sendButton.disabled = true;
              return;
            }

            // 바로 질문 입력
            chatInput.value = questions[currentSectionIndex];
            chatInput.disabled = false;
            sendButton.disabled = false;
          } else {
            // 스크롤해야 보이는 위치라면 스크롤 감지 대기
            chatInput.disabled = true;
            sendButton.disabled = true;
          }
        }
      }
    }

    function initializeChatInput() {
      const chatInput = document.getElementById('chatInput');
      const sendButton = document.getElementById('sendButton');

      if (!chatInput || !sendButton) return;

      // 초기 상태
      chatInput.disabled = true;
      sendButton.disabled = true;

      // 전송 버튼 클릭 이벤트
      sendButton.addEventListener('click', function() {
        if (!isTyping && !chatInput.disabled) {
          if (isFirstAnimation) {
            // 첫 번째는 애니메이션과 함께
            animateFakeCursorToButton(() => {
              sendMessage();
              isFirstAnimation = false;
            });
          } else {
            // 이후에는 바로 전송
            sendMessage();
          }
        }
      });

      // 엔터키 이벤트
      chatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !isTyping && !chatInput.disabled) {
          if (isFirstAnimation) {
            // 첫 번째는 애니메이션과 함께
            animateFakeCursorToButton(() => {
              sendMessage();
              isFirstAnimation = false;
            });
          } else {
            // 이후에는 바로 전송
            sendMessage();
          }
        }
      });

      // 스크롤 이벤트 - 다음 섹션이 화면에 나타나면 질문 입력 + 맨 아래에서 아래 스크롤 시 다음 대화
      const chatMessages = document.getElementById('chatMessages');
      let isAtBottom = false;

      function checkScrollPosition() {
        const scrollTop = chatMessages.scrollTop;
        const scrollHeight = chatMessages.scrollHeight;
        const clientHeight = chatMessages.clientHeight;

        // 현재 표시된 섹션이 있는지 확인
        const sections = document.querySelectorAll('.chat-section');
        const currentSection = sections[currentSectionIndex];

        if (currentSection && currentSection.style.display === 'block') {
          // 섹션의 실제 내용 영역 끝까지 스크롤했는지 확인 (여백 시작점)
          const sectionRect = currentSection.getBoundingClientRect();
          const containerRect = chatMessages.getBoundingClientRect();

          // 섹션 내용이 화면 상단 근처에 있고, 여백 영역에 진입했는지 확인
          const sectionTopInContainer = sectionRect.top - containerRect.top;
          const hasScrolledThroughContent = sectionTopInContainer <= -(sectionRect.height * 0.7); // 내용의 70% 이상 스크롤

          isAtBottom = hasScrolledThroughContent;
        } else {
          // 기본 동작: 스크롤이 없거나 맨 아래에 있는지 확인
          isAtBottom = (scrollHeight <= clientHeight) || (scrollTop + clientHeight >= scrollHeight - 10);
        }
      }

      chatMessages.addEventListener('scroll', function() {
        // 스크롤 입력이 무시되면 이벤트 중단
        if (scrollInputDisabled) {
          return;
        }

        // 대화형 모드에서 사용자가 스크롤했음을 기록
        if (document.body.classList.contains('chat-mode')) {
          hasUserScrolledInChatMode = true;
        }

        checkScrollPosition();

        // 입력창이 비활성화되어 있고 아직 입력된 질문이 없다면
        if (chatInput.disabled && !chatInput.value && currentSectionIndex < questions.length) {
          // 대화형 모드에서 사용자가 스크롤하지 않았으면 질문 표시하지 않음
          if (!hasUserScrolledInChatMode) {
            return;
          }

          const sections = document.querySelectorAll('.chat-section');
          const nextSection = sections[currentSectionIndex];

          // 다음 섹션이 표시되어 있는지 확인 (건너뛴 질문 무시)
          if (nextSection && nextSection.style.display === 'block') {
            // 목차로 이미 노출된 섹션인지 확인
            const isAlreadyExposed = nextSection.querySelector('.question.show') || nextSection.querySelector('.answer.show');

            // 이미 노출된 섹션이면 스크롤 이벤트 무시
            if (isAlreadyExposed) {
              return;
            }

            const rect = nextSection.getBoundingClientRect();
            const containerRect = chatMessages.getBoundingClientRect();

            // 다음 섹션이 화면에 나타나면 질문 입력
            if (rect.top <= containerRect.bottom - 100) {
              chatInput.value = questions[currentSectionIndex];
              chatInput.disabled = false;
              sendButton.disabled = false;
            }
          }
        }
      });

      // 초기 스크롤 위치 확인
      checkScrollPosition();

      // 휠 이벤트 - 맨 아래에서 아래로 스크롤 2번 시 다음 대화 전송
      let scrollAttempts = 0;
      let scrollTimeout;

      // PC용 마우스 휠 이벤트
      chatMessages.addEventListener('wheel', function(e) {
        handleScrollEvent(e.deltaY > 0, e);
      });

      // 모바일용 터치 스크롤 이벤트
      let touchStartY = 0;
      let touchEndY = 0;

      chatMessages.addEventListener('touchstart', function(e) {
        touchStartY = e.changedTouches[0].screenY;
      });

      chatMessages.addEventListener('touchend', function(e) {
        touchEndY = e.changedTouches[0].screenY;

        // 아래로 스와이프 (위에서 아래로)
        const isDownSwipe = touchStartY > touchEndY + 50; // 50px 이상 스와이프

        if (isDownSwipe) {
          handleScrollEvent(true, e);
        }
      });

      function handleScrollEvent(isDownward, event) {
        // 스크롤 입력이 무시되면 이벤트 중단
        if (scrollInputDisabled) {
          if (event.preventDefault) event.preventDefault();
          return;
        }

        // 스크롤 위치 실시간 확인
        checkScrollPosition();

        // 아래로 스크롤하려고 하고, 맨 아래에 있거나 스크롤이 없고, 다음 질문이 준비되어 있으면
        if (isDownward && isAtBottom && !chatInput.disabled && chatInput.value && !isTyping) {
          if (event.preventDefault) event.preventDefault(); // 기본 스크롤 방지

          scrollAttempts++;

          // 이전 타이머 제거
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }

          // 2번 이상 스크롤하면 전송 (모바일에서는 1번으로 조정)
          const requiredAttempts = ('ontouchstart' in window) ? 1 : 2;

          if (scrollAttempts >= requiredAttempts) {
            scrollAttempts = 0; // 카운터 리셋

            // 다음 대화 전송
            if (isFirstAnimation) {
              animateFakeCursorToButton(() => {
                sendMessage();
                isFirstAnimation = false;
              });
            } else {
              sendMessage();
            }
          } else {
            // 1초 후 카운터 리셋
            scrollTimeout = setTimeout(() => {
              scrollAttempts = 0;
            }, 1000);
          }
        }
      }
    }

    function initializeProfileModal() {
      // 프로필 모달 닫기 버튼
      document.getElementById('closeProfile').addEventListener('click', function() {
        document.getElementById('profileModal').style.display = 'none';
      });

      // 모달 오버레이 클릭 시 닫기
      document.querySelector('.tg-modal-overlay').addEventListener('click', function() {
        document.getElementById('profileModal').style.display = 'none';
      });
    }


    function initializeSidebarNavigation() {
      // 초기 breadcrumb 설정 (첫 번째 섹션은 title 표시)
      updateBreadcrumb('intro');

      // PC 사이드바 네비게이션 클릭 이벤트
      document.querySelectorAll('.nav-item').forEach(item => {
        item.addEventListener('click', function(e) {
          e.preventDefault();
          const targetId = this.getAttribute('data-section');
          const targetElement = document.getElementById(targetId);

          if (targetElement) {
            // 스크롤 입력 무시 시작
            disableScrollInput();

            // currentSectionIndex를 클릭한 섹션에 맞게 업데이트
            const sectionIds = ['intro', 'skills-backend', 'experience', 'projects', 'certifications'];
            const targetIndex = sectionIds.indexOf(targetId);
            if (targetIndex !== -1) {
              currentSectionIndex = targetIndex;
            }

            // 클릭한 섹션까지의 모든 섹션 표시
            showSectionsUpTo(targetId);

            // 마지막 섹션(자격증)을 클릭한 경우 입력창 비활성화
            if (targetId === 'certifications') {
              const chatInput = document.getElementById('chatInput');
              const sendButton = document.getElementById('sendButton');

              chatInput.value = '';
              chatInput.placeholder = '';
              chatInput.disabled = true;
              sendButton.disabled = true;
            }

            // 활성 상태 먼저 업데이트 (스크롤 중 변경 방지)
            updateActiveNavItem(targetId);

            // 부드러운 스크롤 (모바일 최적화)
            setTimeout(() => {
              const isMobile = window.innerWidth <= 480;
              const isFirstSection = targetId === 'intro';

              if (isMobile) {
                if (isFirstSection) {
                  // 첫 번째 섹션은 맨 위로 스크롤
                  document.querySelector('.chat-messages').scrollTo({
                    top: 0,
                    behavior: 'smooth'
                  });
                } else {
                  // 다른 섹션들은 질문 부분이 보이도록 조정
                  const chatMessages = document.querySelector('.chat-messages');
                  const headerHeight = document.querySelector('.chat-header').offsetHeight;
                  const targetTop = targetElement.offsetTop;
                  const finalScrollTop = targetTop - headerHeight - 20; // 20px 여백

                  chatMessages.scrollTo({
                    top: Math.max(0, finalScrollTop),
                    behavior: 'smooth'
                  });
                }
              } else {
                targetElement.scrollIntoView({
                  behavior: 'smooth',
                  block: 'start'
                });
              }

              // 스크롤 완료 후 입력 다시 활성화
              setTimeout(() => {
                enableScrollInput();
              }, 1000);
            }, 100);
          }
        });
      });

      // 모바일/태블릿 네비게이션 클릭 이벤트
      document.querySelectorAll('.mobile-nav-item').forEach(item => {
        item.addEventListener('click', function(e) {
          e.preventDefault();
          const targetId = this.getAttribute('data-section');
          const targetElement = document.getElementById(targetId);

          if (targetElement) {
            // 스크롤 입력 무시 시작
            disableScrollInput();

            // currentSectionIndex를 클릭한 섹션에 맞게 업데이트
            const sectionIds = ['intro', 'skills-backend', 'experience', 'projects', 'certifications'];
            const targetIndex = sectionIds.indexOf(targetId);
            if (targetIndex !== -1) {
              currentSectionIndex = targetIndex;
            }

            // 클릭한 섹션까지의 모든 섹션 표시
            showSectionsUpTo(targetId);

            // 마지막 섹션(자격증)을 클릭한 경우 입력창 비활성화
            if (targetId === 'certifications') {
              const chatInput = document.getElementById('chatInput');
              const sendButton = document.getElementById('sendButton');

              chatInput.value = '';
              chatInput.placeholder = '';
              chatInput.disabled = true;
              sendButton.disabled = true;
            }

            // 활성 상태 먼저 업데이트 (스크롤 중 변경 방지)
            updateActiveNavItem(targetId);

            // 부드러운 스크롤 (모바일 최적화)
            setTimeout(() => {
              const isMobile = window.innerWidth <= 480;
              const isFirstSection = targetId === 'intro';

              if (isMobile) {
                if (isFirstSection) {
                  // 첫 번째 섹션은 맨 위로 스크롤
                  document.querySelector('.chat-messages').scrollTo({
                    top: 0,
                    behavior: 'smooth'
                  });
                } else {
                  // 다른 섹션들은 질문 부분이 보이도록 조정
                  const chatMessages = document.querySelector('.chat-messages');
                  const headerHeight = document.querySelector('.chat-header').offsetHeight;
                  const targetTop = targetElement.offsetTop;
                  const finalScrollTop = targetTop - headerHeight - 20; // 20px 여백

                  chatMessages.scrollTo({
                    top: Math.max(0, finalScrollTop),
                    behavior: 'smooth'
                  });
                }
              } else {
                targetElement.scrollIntoView({
                  behavior: 'smooth',
                  block: 'start'
                });
              }

              // 스크롤 완료 후 입력 다시 활성화
              setTimeout(() => {
                enableScrollInput();
              }, 1000);
            }, 100);
          }
        });
      });

      // 스크롤 이벤트로 현재 섹션 감지
      let ticking = false;
      document.querySelector('.chat-messages').addEventListener('scroll', function() {
        // 스크롤 입력이 무시되는 중이면 네비게이션 업데이트도 중단
        if (scrollInputDisabled) {
          return;
        }

        if (!ticking) {
          requestAnimationFrame(function() {
            updateActiveSection();
            ticking = false;
          });
          ticking = true;
        }
      });
    }

    function showSectionsUpTo(targetSectionId) {
      const chatMessages = document.getElementById('chatMessages');
      const sections = document.querySelectorAll('.chat-section');
      const sectionIds = ['intro', 'skills-backend', 'experience', 'projects', 'certifications'];

      // 타겟 섹션의 인덱스 찾기
      const targetIndex = sectionIds.indexOf(targetSectionId);

      if (targetIndex !== -1) {
        // 여백 축소 처리
        let hasHeightChange = false;

        // 타겟 섹션까지의 모든 섹션 표시
        sections.forEach((section, index) => {
          if (index <= targetIndex) {
            section.style.display = 'block';

            // 목차로 바로 표시되는 섹션들에 show 클래스 추가 (스크롤 이벤트 방지용)
            const questions = section.querySelectorAll('.question');
            const answers = section.querySelectorAll('.answer');
            questions.forEach(q => q.classList.add('show'));
            answers.forEach(a => a.classList.add('show'));

            // 타겟 섹션 이전의 모든 섹션을 읽기 완료로 표시
            if (index < targetIndex && !section.classList.contains('read-completed')) {
              section.classList.add('read-completed');
              hasHeightChange = true;
            }
          }
        });

        // 자격증 섹션이 표시되면 바로 종료 메시지 표시
        if (targetSectionId === 'certifications') {
          showEndMessage();
        }

        // currentSectionIndex는 다음에 표시될 질문을 위해 targetIndex로 설정하되,
        // 아직 표시되지 않은 다음 섹션이 있다면 계속 진행할 수 있도록 함
        // 목차로 건너뛴 경우에도 순차적 진행이 가능하도록 함

        // 여백 축소 후 입력창 상태 업데이트
        setTimeout(() => {
          updateInputForSection();
        }, hasHeightChange ? 850 : 100); // 여백 변화가 있으면 애니메이션 완료 후, 없으면 즉시
      }
    }

    function updateInputForSection() {
      const chatInput = document.getElementById('chatInput');
      const sendButton = document.getElementById('sendButton');
      const sections = document.querySelectorAll('.chat-section');

      // 표시되지 않은 다음 섹션 찾기
      let nextHiddenIndex = -1;
      sections.forEach((section, index) => {
        if (section.style.display === 'none' && nextHiddenIndex === -1) {
          nextHiddenIndex = index;
        }
      });

      if (nextHiddenIndex !== -1 && nextHiddenIndex < questions.length) {
        // 다음 숨겨진 섹션이 있음
        chatInput.value = questions[nextHiddenIndex];
        chatInput.disabled = false;
        sendButton.disabled = false;
        // currentSectionIndex를 다음 질문으로 업데이트
        currentSectionIndex = nextHiddenIndex;
      } else {
        // 모든 섹션이 표시됨
        chatInput.value = '';
        chatInput.placeholder = '';
        chatInput.disabled = true;
        sendButton.disabled = true;
      }
    }

    function updateActiveNavItem(sectionId) {
      // PC 사이드바 네비게이션 업데이트
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
      });
      const activeItem = document.querySelector('.nav-item[data-section="' + sectionId + '"]');
      if (activeItem) {
        activeItem.classList.add('active');
      }

      // 모바일/태블릿 네비게이션 업데이트
      document.querySelectorAll('.mobile-nav-item').forEach(item => {
        item.classList.remove('active');
      });
      const activeMobileItem = document.querySelector('.mobile-nav-item[data-section="' + sectionId + '"]');
      if (activeMobileItem) {
        activeMobileItem.classList.add('active');

        // 활성 항목이 화면에 보이도록 스크롤
        activeMobileItem.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest',
          inline: 'center'
        });
      }

      // breadcrumb 업데이트
      updateBreadcrumb(sectionId);
    }

    function updateBreadcrumb(sectionId) {
      const headerTitle = document.getElementById('headerTitle');
      const breadcrumb = document.getElementById('breadcrumb');
      const currentSection = document.getElementById('currentSection');
      const chatHeader = document.querySelector('.chat-header');

      // 요소들이 존재하는지 확인
      if (!headerTitle || !breadcrumb || !currentSection || !chatHeader) {
        return;
      }

      if (sectionId && sectionNames[sectionId]) {
        // 첫 번째 섹션이 아니면 섹션 이름만 표시
        if (sectionId !== 'intro') {
          headerTitle.style.display = 'none';
          breadcrumb.style.display = 'flex';
          currentSection.textContent = sectionNames[sectionId];
          chatHeader.classList.add('compact'); // 헤더 크기 축소
        } else {
          // 첫 번째 섹션이면 원래 타이틀 표시
          headerTitle.style.display = 'block';
          breadcrumb.style.display = 'none';
          chatHeader.classList.remove('compact'); // 헤더 크기 복원
        }
      }
    }

    function updateActiveSection() {
      const sections = document.querySelectorAll('.chat-section');
      const scrollContainer = document.querySelector('.chat-messages');
      const containerHeight = scrollContainer.clientHeight;

      let currentSection = null;

      sections.forEach(section => {
        // 표시되지 않은 섹션은 건너뛰기
        if (section.style.display === 'none') {
          return;
        }

        const rect = section.getBoundingClientRect();
        const containerRect = scrollContainer.getBoundingClientRect();
        const relativeTop = rect.top - containerRect.top;

        // 섹션이 화면 상단 1/3 지점에 있으면 활성화 (표시된 섹션만)
        if (relativeTop <= containerHeight / 3 && relativeTop >= -rect.height + containerHeight / 3) {
          currentSection = section.id;
        }
      });

      if (currentSection) {
        updateActiveNavItem(currentSection);
      }
    }

    function updateQuestionAvatars() {
      document.querySelectorAll('.question').forEach(question => {
        let avatarContainer = question.querySelector('.avatar-container');

        if (!avatarContainer) {
          avatarContainer = document.createElement('div');
          avatarContainer.className = 'avatar-container';

          const avatar = document.createElement('div');
          avatar.className = 'avatar user-avatar';
          // SVG 제거: 이제 CSS 배경 이미지(챗봇.jpg) 사용

          avatarContainer.appendChild(avatar);
          question.appendChild(avatarContainer);
        }
      });
    }

    function initializeModeToggle() {
      const toggleBtn = document.getElementById('modeToggle');

      toggleBtn.addEventListener('click', function() {
        const body = document.body;
        const isPdfMode = body.classList.contains('pdf-mode');

        if (isPdfMode) {
          // PDF 모드에서 채팅 모드로 전환
          body.classList.remove('pdf-mode');
          body.classList.add('chat-mode');

          toggleBtn.classList.remove('pdf-mode-active');
          toggleBtn.classList.add('chat-mode-active');
          toggleBtn.title = 'PDF 형태로 전환';

          // 채팅 모드 복원
          restoreChatMode();
        } else {
          // 채팅 모드에서 PDF 모드로 전환
          body.classList.remove('chat-mode');
          body.classList.add('pdf-mode');

          toggleBtn.classList.remove('chat-mode-active');
          toggleBtn.classList.add('pdf-mode-active');
          toggleBtn.title = '대화형으로 전환';

          // PDF 모드 설정
          enterPdfMode();
        }
      });
    }

    function enterPdfMode() {
      // 대화형 모드의 현재 상태 저장
      chatModeState.visibleSections = [];
      document.querySelectorAll('.chat-section').forEach(section => {
        if (section.style.display !== 'none') {
          chatModeState.visibleSections.push(section.id);
        }
      });
      chatModeState.currentSectionIndex = currentSectionIndex;
      chatModeState.hasUserScrolled = hasUserScrolledInChatMode;

      // 대화형 모드 스크롤 추적 리셋
      hasUserScrolledInChatMode = false;

      // 모든 섹션 표시
      const sections = document.querySelectorAll('.chat-section');
      sections.forEach(section => {
        section.style.display = 'block';

        // 모든 질문과 답변에 show 클래스 추가
        const questions = section.querySelectorAll('.question');
        const answers = section.querySelectorAll('.answer');
        questions.forEach(q => q.classList.add('show'));
        answers.forEach(a => a.classList.add('show'));
      });


      // 페이지 상단으로 스크롤
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function restoreChatMode() {
      // PDF 모드에서 추가된 모든 show 클래스 제거
      document.querySelectorAll('.question.show, .answer.show').forEach(element => {
        element.classList.remove('show');
      });

      // 종료 메시지 숨기기
      const endMessage = document.getElementById('end-message');
      if (endMessage) {
        endMessage.style.display = 'none';
        endMessage.classList.remove('show');
      }

      // 모든 섹션 숨기기
      hideAllSections();

      // 저장된 상태에서 표시되었던 섹션들만 복원
      if (chatModeState.visibleSections.length > 0) {
        chatModeState.visibleSections.forEach(sectionId => {
          const section = document.getElementById(sectionId);
          if (section) {
            section.style.display = 'block';
            
            // 해당 섹션의 질문과 답변에 show 클래스 다시 추가
            const questions = section.querySelectorAll('.question');
            const answers = section.querySelectorAll('.answer');
            questions.forEach(q => q.classList.add('show'));
            answers.forEach(a => a.classList.add('show'));
          }
        });
      }

      // 저장된 인덱스와 스크롤 상태 복원
      currentSectionIndex = chatModeState.currentSectionIndex;
      hasUserScrolledInChatMode = chatModeState.hasUserScrolled;

      // 현재 활성 섹션 유지
      const currentSection = document.querySelector('.nav-item.active')?.getAttribute('data-section') || 'intro';
      updateActiveNavItem(currentSection);
      updateBreadcrumb(currentSection);

      // 입력창 상태 업데이트
      updateInputForSection();

      // 스크롤 위치 복원
      const targetElement = document.getElementById(currentSection);
      if (targetElement) {
        setTimeout(() => {
          targetElement.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
          });
        }, 100);
      }
    }

    function initializePdfDownload() {
      const downloadBtn = document.getElementById('pdfDownload');

      downloadBtn.addEventListener('click', function() {
        downloadPDF();
      });
    }

    function downloadPDF() {
      // 현재 모드 저장
      const currentMode = document.body.classList.contains('pdf-mode');

      // PDF 모드로 전환 (이미 PDF 모드가 아닌 경우)
      if (!currentMode) {
        document.body.classList.remove('chat-mode');
        document.body.classList.add('pdf-mode');
        enterPdfMode();
      }

      // 잠시 대기 후 PDF 생성 (렌더링 완료를 위해)
      setTimeout(() => {
        // 페이지 타이틀 설정
        const originalTitle = document.title;
        document.title = 'Developer Portfolio - 김지훈';

        // 브라우저의 인쇄 기능 호출
        window.print();

        // 원래 타이틀 복원
        document.title = originalTitle;

        // 원래 모드로 복원 (PDF 모드가 아니었던 경우)
        if (!currentMode) {
          setTimeout(() => {
            document.body.classList.remove('pdf-mode');
            document.body.classList.add('chat-mode');

            const toggleBtn = document.getElementById('modeToggle');
            toggleBtn.classList.remove('pdf-mode-active');
            toggleBtn.classList.add('chat-mode-active');
            toggleBtn.title = 'PDF 형태로 전환';

            restoreChatMode();
          }, 1000);
        }
      }, 500);
    }

  </script>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    // Chart.js 차트 초기화
    document.addEventListener('DOMContentLoaded', function() {
      // 백엔드 언어 & 프레임워크 차트
      const backendCtx = document.getElementById('backendChart');
      if (backendCtx) {
        const backendChart = new Chart(backendCtx, {
          type: 'doughnut',
          data: {
            labels: [
              'Node.js & TypeScript',
              'Nest.js',
              'Go',
              'Apache Kafka'
            ],
            datasets: [{
              data: [50, 25, 15, 10],
              backgroundColor: [
                '#3498db',
                '#2ecc71',
                '#9b59b6',
                '#34495e'
              ],
              borderWidth: 0,
              hoverBorderWidth: 3,
              hoverBorderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: true,
                position: 'right',
                labels: {
                  boxWidth: 12,
                  padding: 15,
                  font: {
                    size: 12
                  },
                  generateLabels: function(chart) {
                    const data = chart.data;
                    return data.labels.map((label, index) => {
                      const value = data.datasets[0].data[index];
                      return {
                        text: `${label} (${value}%)`,
                        fillStyle: data.datasets[0].backgroundColor[index],
                        strokeStyle: data.datasets[0].backgroundColor[index],
                        lineWidth: 0,
                        index: index
                      };
                    });
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#fff',
                bodyColor: '#fff',
                borderColor: 'rgba(255, 255, 255, 0.1)',
                borderWidth: 1,
                callbacks: {
                  label: function(context) {
                    return context.label + ': ' + context.parsed + '%';
                  }
                }
              }
            },
            cutout: '60%',
            animation: {
              animateRotate: true,
              duration: 1500
            },
            onHover: (event, activeElements, chart) => {
              updateCenterText(chart, activeElements, 'backend');
            }
          }
        });

        // 초기 중앙 텍스트 설정
        setTimeout(() => {
          updateCenterText(backendChart, [], 'backend');
        }, 1600);
      }

      // 데이터베이스 차트
      const databaseCtx = document.getElementById('databaseChart');
      if (databaseCtx) {
        const databaseChart = new Chart(databaseCtx, {
          type: 'doughnut',
          data: {
            labels: [
              'MySQL',
              'Redis',
              'PostgreSQL'
            ],
            datasets: [{
              data: [45, 30, 25],
              backgroundColor: [
                '#e74c3c',
                '#f39c12',
                '#16a085'
              ],
              borderWidth: 0,
              hoverBorderWidth: 3,
              hoverBorderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: true,
                position: 'right',
                labels: {
                  boxWidth: 12,
                  padding: 15,
                  font: {
                    size: 12
                  },
                  generateLabels: function(chart) {
                    const data = chart.data;
                    return data.labels.map((label, index) => {
                      const value = data.datasets[0].data[index];
                      return {
                        text: `${label} (${value}%)`,
                        fillStyle: data.datasets[0].backgroundColor[index],
                        strokeStyle: data.datasets[0].backgroundColor[index],
                        lineWidth: 0,
                        index: index
                      };
                    });
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#fff',
                bodyColor: '#fff',
                borderColor: 'rgba(255, 255, 255, 0.1)',
                borderWidth: 1,
                callbacks: {
                  label: function(context) {
                    return context.label + ': ' + context.parsed + '%';
                  }
                }
              }
            },
            cutout: '60%',
            animation: {
              animateRotate: true,
              duration: 1500
            },
            onHover: (event, activeElements, chart) => {
              updateCenterText(chart, activeElements, 'database');
            }
          }
        });

        // 초기 중앙 텍스트 설정
        setTimeout(() => {
          updateCenterText(databaseChart, [], 'database');
        }, 1600);
      }

      // DevOps & 인프라 차트
      const devopsCtx = document.getElementById('devopsChart');
      if (devopsCtx) {
        const devopsChart = new Chart(devopsCtx, {
          type: 'doughnut',
          data: {
            labels: [
              'Naver Cloud Platform',
              'AWS',
              'Docker',
              'Kubernetes',
              'Nginx',
              'Git',
              'Linux'
            ],
            datasets: [{
              data: [25, 23, 20, 12, 10, 7, 3],
              backgroundColor: [
                '#ff9500',
                '#232f3e',
                '#0db7ed',
                '#326ce5',
                '#269539',
                '#f05032',
                '#fcc624'
              ],
              borderWidth: 0,
              hoverBorderWidth: 3,
              hoverBorderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: true,
                position: 'right',
                labels: {
                  boxWidth: 12,
                  padding: 15,
                  font: {
                    size: 12
                  },
                  generateLabels: function(chart) {
                    const data = chart.data;
                    return data.labels.map((label, index) => {
                      const value = data.datasets[0].data[index];
                      return {
                        text: `${label} (${value}%)`,
                        fillStyle: data.datasets[0].backgroundColor[index],
                        strokeStyle: data.datasets[0].backgroundColor[index],
                        lineWidth: 0,
                        index: index
                      };
                    });
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#fff',
                bodyColor: '#fff',
                borderColor: 'rgba(255, 255, 255, 0.1)',
                borderWidth: 1,
                callbacks: {
                  label: function(context) {
                    return context.label + ': ' + context.parsed + '%';
                  }
                }
              }
            },
            cutout: '60%',
            animation: {
              animateRotate: true,
              duration: 1500
            },
            onHover: (event, activeElements, chart) => {
              updateCenterText(chart, activeElements, 'devops');
            }
          }
        });

        // 초기 중앙 텍스트 설정
        setTimeout(() => {
          updateCenterText(devopsChart, [], 'devops');
        }, 1600);
      }
    });

    // 차트 중앙 텍스트 업데이트 함수
    function updateCenterText(chart, activeElements, chartType) {
      const canvasPosition = Chart.helpers.getRelativePosition(chart.chartArea, chart.canvas);
      const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
      const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;

      // 기존 중앙 텍스트 제거
      const existingText = chart.canvas.parentNode.querySelector('.chart-center-text');
      if (existingText) {
        existingText.remove();
      }

      // 새 중앙 텍스트 요소 생성
      const centerTextDiv = document.createElement('div');
      centerTextDiv.className = 'chart-center-text';
      centerTextDiv.style.position = 'absolute';
      centerTextDiv.style.left = '50%';
      centerTextDiv.style.top = '50%';
      centerTextDiv.style.transform = 'translate(-50%, -50%)';
      centerTextDiv.style.textAlign = 'center';
      centerTextDiv.style.pointerEvents = 'none';
      centerTextDiv.style.zIndex = '10';

      let title = '';
      let percentage = '';
      let description = '';

      if (activeElements.length > 0) {
        // 호버된 항목이 있을 때
        const index = activeElements[0].index;
        const dataset = chart.data.datasets[0];
        title = chart.data.labels[index];
        percentage = dataset.data[index] + '%';

        // 간단한 설명 추가
        if (chartType === 'backend') {
          const descriptions = {
            'Node.js & TypeScript': '주력 개발 언어',
            'Nest.js': '엔터프라이즈 프레임워크',
            'Go': '고성능 서비스',
            'Apache Kafka': '이벤트 스트리밍'
          };
          description = descriptions[title] || '';
        } else if (chartType === 'database') {
          const descriptions = {
            'MySQL': '주 관계형 DB',
            'Redis': '캐싱 & 세션',
            'PostgreSQL': '복잡 쿼리용'
          };
          description = descriptions[title] || '';
        } else if (chartType === 'devops') {
          const descriptions = {
            'Naver Cloud Platform': '상용 서비스 운영',
            'AWS': '다양한 서비스 활용',
            'Docker': '컨테이너화',
            'Kubernetes': '오케스트레이션',
            'Nginx': '리버스 프록시',
            'Git': '버전 관리',
            'Linux': '서버 운영'
          };
          description = descriptions[title] || '';
        }
      } else {
        // 기본 상태
        if (chartType === 'backend') {
          title = 'Backend';
          percentage = '100%';
          description = '기술 스택';
        } else if (chartType === 'database') {
          title = 'Database';
          percentage = '100%';
          description = '기술 스택';
        } else if (chartType === 'devops') {
          title = 'DevOps';
          percentage = '100%';
          description = '기술 스택';
        }
      }

      centerTextDiv.innerHTML = `
        <div style="font-size: 16px; font-weight: 600; color: #007AFF; margin-bottom: 4px;">${title}</div>
        <div style="font-size: 24px; font-weight: 700; color: #1a1a1a; margin-bottom: 2px;">${percentage}</div>
        <div style="font-size: 12px; color: #666;">${description}</div>
      `;

      // 차트 컨테이너에 추가
      chart.canvas.parentNode.style.position = 'relative';
      chart.canvas.parentNode.appendChild(centerTextDiv);
    }

    // 이미지 갤러리 기능
    function initializeImageGallery() {
      document.querySelectorAll('.project-card').forEach(card => {
        const gallery = card.querySelector('.image-gallery');
        const container = gallery.querySelector('.image-container');
        const images = container.querySelectorAll('img, .image-placeholder');
        const prevBtn = gallery.querySelector('.prev-btn');
        const nextBtn = gallery.querySelector('.next-btn');
        const navContainer = gallery.querySelector('.gallery-nav');
        const indicators = gallery.querySelector('.gallery-indicators');

        let currentIndex = 0;

        // 이미지 로드 후 갤러리 높이 조정
        function adjustGalleryHeight() {
          const currentImage = images[currentIndex];
          if (currentImage && currentImage.tagName === 'IMG') {
            const img = new Image();
            img.onload = function() {
              const aspectRatio = img.height / img.width;
              const containerWidth = gallery.offsetWidth;
              let idealHeight = containerWidth * aspectRatio;

              // 최소/최대 높이 제한
              idealHeight = Math.max(200, Math.min(300, idealHeight));

              gallery.style.height = idealHeight + 'px';
              container.style.height = idealHeight + 'px';
            };
            img.src = currentImage.src;
          }
        }

        // 이미지가 여러 개인 경우에만 네비게이션 표시
        if (images.length > 1) {
          navContainer.style.display = 'flex';
          indicators.style.display = 'flex';

          // 인디케이터 생성
          indicators.innerHTML = '';
          images.forEach((_, index) => {
            const indicator = document.createElement('span');
            indicator.className = 'indicator';
            if (index === 0) indicator.classList.add('active');
            indicator.addEventListener('click', () => goToSlide(index));
            indicators.appendChild(indicator);
          });
        }

        function updateGallery() {
          container.style.transform = `translateX(-${currentIndex * 100}%)`;

          // 인디케이터 업데이트
          indicators.querySelectorAll('.indicator').forEach((indicator, index) => {
            indicator.classList.toggle('active', index === currentIndex);
          });

          // 버튼 상태 업데이트
          prevBtn.disabled = currentIndex === 0;
          nextBtn.disabled = currentIndex === images.length - 1;

          // 현재 이미지에 맞춰 높이 조정
          adjustGalleryHeight();
        }

        function goToSlide(index) {
          currentIndex = index;
          updateGallery();
        }

        function nextSlide() {
          if (currentIndex < images.length - 1) {
            currentIndex++;
            updateGallery();
          }
        }

        function prevSlide() {
          if (currentIndex > 0) {
            currentIndex--;
            updateGallery();
          }
        }

        // 버튼 이벤트
        prevBtn.addEventListener('click', prevSlide);
        nextBtn.addEventListener('click', nextSlide);

        // 이미지 클릭으로 확대
        images.forEach((image, index) => {
          image.addEventListener('click', () => {
            if (image.tagName === 'IMG') {
              openImageModal(image.src, images, index);
            }
          });
        });

        // 초기 상태 설정
        updateGallery();
      });
    }

    // 이미지 모달 기능
    function openImageModal(imageSrc, images, currentIndex) {
      const modal = document.getElementById('imageModal');
      const modalImage = document.getElementById('modalImage');
      const modalPrev = document.getElementById('modalPrev');
      const modalNext = document.getElementById('modalNext');
      const modalClose = document.getElementById('modalClose');

      // 실제 이미지만 필터링
      const realImages = Array.from(images).filter(img => img.tagName === 'IMG');
      let modalIndex = realImages.findIndex(img => img.src === imageSrc);

      function updateModalImage() {
        modalImage.src = realImages[modalIndex].src;
        modalImage.alt = realImages[modalIndex].alt;

        modalPrev.disabled = modalIndex === 0;
        modalNext.disabled = modalIndex === realImages.length - 1;
      }

      function nextModalImage() {
        if (modalIndex < realImages.length - 1) {
          modalIndex++;
          updateModalImage();
        }
      }

      function prevModalImage() {
        if (modalIndex > 0) {
          modalIndex--;
          updateModalImage();
        }
      }

      function closeModal() {
        modal.classList.remove('show');
        document.body.style.overflow = '';
      }

      // 이벤트 리스너 설정
      modalPrev.onclick = prevModalImage;
      modalNext.onclick = nextModalImage;
      modalClose.onclick = closeModal;

      // 키보드 네비게이션
      function handleKeydown(e) {
        switch(e.key) {
          case 'Escape':
            closeModal();
            break;
          case 'ArrowLeft':
            prevModalImage();
            break;
          case 'ArrowRight':
            nextModalImage();
            break;
        }
      }

      // 배경 클릭으로 닫기
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeModal();
        }
      };

      document.addEventListener('keydown', handleKeydown);

      // 모달 열기
      updateModalImage();
      modal.classList.add('show');
      document.body.style.overflow = 'hidden';

      // 모달이 닫힐 때 이벤트 리스너 제거
      modal.addEventListener('transitionend', function onTransitionEnd() {
        if (!modal.classList.contains('show')) {
          document.removeEventListener('keydown', handleKeydown);
          modal.removeEventListener('transitionend', onTransitionEnd);
        }
      });
    }

    // 페이지 로드 시 이미지 갤러리 초기화
    document.addEventListener('DOMContentLoaded', function() {
      // 기존 초기화 함수들이 완료된 후 갤러리 초기화
      setTimeout(() => {
        initializeImageGallery();
      }, 100);
    });
  </script>
</body>

</html>
